#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

sub sqlplusExecPath(@);
sub readProps();
sub createSqlFile($);
sub indent($$);

my $propFile = "/opt/escribe/conf/runora.properties";

my @SQLPLUS_EXECS = qw(sqlplus gqlplus);

my @sqlplusExecPathPrefOrderScriptFile = qw(sqlplus gqlplus);
my @sqlplusExecPathPrefOrderNoScriptFile = qw(gqlplus sqlplus);

my $okSqlplusExecCmdlineArgs = join "|", map {"--$_"} @SQLPLUS_EXECS;

my $examplePropFmt = "example $propFile:
    #this describes one database, with DB_NAME=ehrdev
    #the DB_NAME is the same as the SID for convenience
    default=ehrdev    #default db name when no DB_NAME is given
    exec=sqlplus      #optional, overrides gqlplus/sqlplus detection

    ehrdev.sid=ehrdev                               #db SID
    ehrdev.host=ehr-db.dev.int.aws.lillegroup.com   #db hostname or IP
    ehrdev.port=2483                                #db port
    ehrdev.username=my_schema                       #db user/username/schema
    ehrdev.password=toodles                         #db password
    ehrdev.adminusername=sysdbards                  #username with --admin
    ehrdev.adminpassword=poodles                    #password with --admin
    ehrdev.altusername=my_other_schema              #username with --alt
    ehrdev.altpassword=bargle                       #password with --alt
";

my $SQL_CODE_PREFIX = ""
  . "--generated by $0\n"
  . "WHENEVER SQLERROR EXIT FAILURE;\n"
  . "WHENEVER OSERROR EXIT FAILURE;\n"
  . "SET TIMING ON;\n"
  . "SET LINESIZE 120;\n"
  . "SET PAGESIZE 50000;\n"
;
my $SQL_CODE_SUFFIX = ";\nCOMMIT;\nEXIT;\n";

my $PLSQL_CODE_PREFIX = "${SQL_CODE_PREFIX}BEGIN ";
my $PLSQL_CODE_SUFFIX = "; END;\n/\nCOMMIT;\nEXIT;\n";

my $usageFmt = "Usage:
  $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [-q] [--admin|--alt] [SQL_SCRIPT_FILE]
    read <username>, <password>, <host>, <port>, and <sid>
      from the properties of the indicated DB_NAME in
      '$propFile'
    run:
      'SQLPLUS_EXEC <username>/<password>\@<host>:<port>/<sid>'
        or
      'SQLPLUS_EXEC <username>/<password>\@<host>:<port>/<sid> \@SQL_SCRIPT_FILE'

  $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [-q] [--admin|--alt] --sql SQL_CODE
    similar to: $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [--admin|--alt] <TMP_FILE>
    after creating TMP_FILE with the content:\n" .
      indent("$SQL_CODE_PREFIX<SQL_CODE>$SQL_CODE_SUFFIX", "      ") . "

  $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [-q] [--admin|--alt] --proc|--plsql PLSQL_CODE
    similar to: $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [--admin|--alt] TMP_FILE
    after creating TMP_FILE with the content:\n" .
      indent("$PLSQL_CODE_PREFIX<PLSQL_CODE>$PLSQL_CODE_SUFFIX", "      ") . "

  $0 [$okSqlplusExecCmdlineArgs] [DB_NAME] [-q] [--admin|--alt] --get|--print|--db
    print a line containing: \"<username>/<password>\@<host>:<port>/<sid>\"

  DB_NAME
    one of [\%s], default is \%s
    this can be any word (alphanumeric plus underscore),
      as long as its used consistently in $propFile
    its generally a good idea to make it the same as SID

  SQL_SCRIPT_FILE
    path to a file containing a SQL script to run with '\@'
    also, if given, change preference for SQLPLUS_EXEC:
      [@sqlplusExecPathPrefOrderNoScriptFile] => [@sqlplusExecPathPrefOrderScriptFile]

  SQLPLUS_EXEC
    either sqlplus or a drop-in replacement with the same syntax

    1) if one of [$okSqlplusExecCmdlineArgs] is given, use that
    2) if 'exec' is in '$propFile', use that
      e.g.: 'exec=/usr/local/bin/gqlplus', or 'exec=sqlplus'
    3) if an exec is found on the path using which, use that
       preference is given, in decreasing priority:
         if SQL_SCRIPT_FILE is NOT given
           [@sqlplusExecPathPrefOrderNoScriptFile]
         if SQL_SCRIPT_FILE is given
           [@sqlplusExecPathPrefOrderScriptFile]
    4) if no exec is found, an error is thrown

  -q
    suppress all STDOUT/STDERR output until running SQLPLUS_EXEC
    specifically:
      do not print the command to STDERR
      do not print TMP_FILE or contents to STDERR
  --admin
    use adminusername and adminpassword from $propFile
  --alt
    use altusername and altpassword from $propFile

  =========================================================================
  $examplePropFmt
";

sub main(@){
  die "$propFile not found\n\n$examplePropFmt" if not -f $propFile;

  my ($defaultDbName, $sqlplusExecProp, $dbs) = readProps;
  my $okDbNames = join "|", sort keys %$dbs;

  die "no dbs found in $propFile\n\n$examplePropFmt" if keys %$dbs == 0;

  my $sqlplusExecCmdlineArg = undef;
  if(@_ > 0 and $_[0] =~ /^($okSqlplusExecCmdlineArgs)$/){
    my $arg = shift;
    for my $sqlplusExec(@SQLPLUS_EXECS){
      if($arg =~ /^--$sqlplusExec$/){
        $sqlplusExecCmdlineArg = $sqlplusExec;
      }
    }
    die "unknown sqlplus exec: $arg\n" if not defined $sqlplusExecCmdlineArg;
  }

  my $dbName = $defaultDbName;
  if(@_ > 0 and $_[0] =~ /^($okDbNames)/){
    $dbName = shift;
  }
  die "No default db found in $propFile\n$examplePropFmt" if not defined $dbName;

  my $quiet = 0;
  if(@_ > 0 and $_[0] =~ /^(-q)$/){
    shift;
    $quiet = 1;
  }

  my $admin = undef;
  my $alt = undef;
  if(@_ > 0 and $_[0] =~ /^(--admin)$/){
    $admin = shift;
  }elsif(@_ > 0 and $_[0] =~ /^(--alt)$/){
    $alt = shift;
  }

  my $file = undef;
  my $get = 0;
  if(@_ == 2 and $_[0] =~ /^(--sql)$/){
    shift;
    my $sql = shift;
    $file = createSqlFile "${SQL_CODE_PREFIX}${sql}${SQL_CODE_SUFFIX}";
    print STDERR "$file:$sql\n" unless $quiet;
  }elsif(@_ == 2 and $_[0] =~ /^(--plsql|--proc)$/){
    shift;
    my $plsql = shift;
    $file = createSqlFile "${PLSQL_CODE_PREFIX}${plsql}${PLSQL_CODE_SUFFIX}";
    print STDERR "$file:$plsql\n" unless $quiet;
  }elsif(@_ == 1 and -f $_[0]){
    $file = shift;
  }elsif(@_ == 1 and $_[0] =~ /^(--get|--print|--db)$/){
    shift;
    $get = 1;
  }

  if(@_ > 0){
    my $usage = sprintf $usageFmt, $okDbNames, $defaultDbName;
    die $usage;
  }

  my $db = $$dbs{$dbName};

  my $sid = $$db{sid};
  my $host = $$db{host};
  my $port = $$db{port};

  my ($username, $password);
  if(defined $admin){
    ($username, $password) = ($$db{adminusername}, $$db{adminpassword});
  }elsif(defined $alt){
    ($username, $password) = ($$db{altusername}, $$db{altpassword});
  }else{
    ($username, $password) = ($$db{username}, $$db{password});
  }

  die "missing sid for db=$dbName\n" if not defined $sid;
  die "missing host for db=$dbName\n" if not defined $host;
  die "missing port for db=$dbName\n" if not defined $port;
  die "missing username for db=$dbName\n" if not defined $username;
  die "missing password for db=$dbName\n" if not defined $password;

  my $sqlplusExec;
  if(defined $sqlplusExecCmdlineArg){
    $sqlplusExec = $sqlplusExecCmdlineArg;
  }elsif(defined $sqlplusExecProp){
    $sqlplusExec = $sqlplusExecProp;
  }else{
    if(defined $file){
      $sqlplusExec = sqlplusExecPath @sqlplusExecPathPrefOrderScriptFile;
    }else{
      $sqlplusExec = sqlplusExecPath @sqlplusExecPathPrefOrderNoScriptFile;
    }
  }

  die "no sqlplus exec found\n" if not defined $sqlplusExec;

  my $dbString = "$username/$password\@$host:$port/$sid";

  if($get){
    print "$dbString\n";
  }else{
    my @cmd = ($sqlplusExec, $dbString);
    push @cmd, "\@$file" if defined $file;
    my $obfCmd = "@cmd";
    $obfCmd =~ s/$password/<PASSWORD>/g;
    print STDERR "$obfCmd\n" unless $quiet;
    exec @cmd;
  }
}

sub sqlplusExecPath(@){
  my @sqlplusExecPathPrefOrder = @_;
  for my $sqlplusExecPath(@sqlplusExecPathPrefOrder){
    my $path = `which $sqlplusExecPath 2>/dev/null`;
    my $success = $? == 0;

    chomp $path;
    if($success and -e $path and -x $path and $path =~ /$sqlplusExecPath/){
      return $path;
    }
  }

  return undef;
}

sub readProps(){
  my @lines = `cat $propFile 2>/dev/null`;
  my $defaultDb = undef;
  my $okFields = join "|", qw(
    sid host port username password
    adminusername adminpassword
    altusername altpassword
  );
  my $sqlplusExecProp = undef;
  my $dbs = {};
  for my $line(@lines){
    $line =~ s/#.*//;
    if($line =~ /^default\s*=\s*(.+)$/){
      $defaultDb = $1;
    }elsif($line =~ /^exec\s*=\s*(.+)$/){
      $sqlplusExecProp = $1;
    }elsif($line =~ /^(\w+)\.($okFields)\s*=\s*(.+)$/){
      my ($dbName, $field, $value) = ($1, $2, $3);

      $$dbs{$dbName} = {} if not defined $$dbs{$dbName};
      $$dbs{$dbName}{$field} = $value;
    }
  }
  return ($defaultDb, $sqlplusExecProp, $dbs);
}

sub createSqlFile($){
  my ($sql) = @_;
  my $millis = int(time*1000);
  my $tmpFile = "/tmp/runora-sql-file-$millis.sql";
  open FH, "> $tmpFile" or die "Could not write $tmpFile\n";
  print FH $sql;
  close FH;
  return $tmpFile;
}

sub indent($$){
  my ($s, $indent) = @_;
  my @lines = split /\n/, $s;
  s/^/$indent/ foreach @lines;
  return join '', map {"$_\n"} @lines;
}

&main(@ARGV);
